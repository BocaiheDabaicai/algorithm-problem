## 自我介绍

面试官你好，我叫刘坚，是一名前端开发工程师，接触前端开发有一年多的时间，目前是公司唯一的前端开发工程师，所有前端技术均是自学，技术栈是Vue全家桶，对Nuxt有简单了解和使用，我主导和参与的项目有数据大屏、批次管理系统、宿舍管理系统。

修正

面试官你好，我叫刘坚，目前在一家国企单位从事前端开发工作，有一年多的前端开发经验，目前主导过数据大屏项目、宿舍管理项目（内部管理平台）等等，我现在掌握的是vue前端开发技术栈，对Nuxt有一定的了解，正在工作之余使用nuxt来构建自己的博客网站，因为业余的时候喜欢去探索技术、研究一些技术的实现，所以想以技术专家的方向来发展自己

---

### 项目简介

数据大屏项目，这个项目用于展示公司销售相关的关键数据，给管理层提供一个直观、实时的界面，帮助管理层快速获取最新信息并作出有效的商业决策。主要使用的技术栈是`Vue全家桶+Echarts+Axios`

修正

我主要想介绍一下数据大屏项目，这个项目主要是提供公司的关键数据，帮助管理层快速获取最新的信息，辅助公司做出有效的商业决策。这个项目的主要技术栈是`vue+echarts+axios`

---

## 项目价值点

首先是首屏加载优化

1. 首屏加载优化，严格来说应该是加载优化
   
   - 问题描述：加载首屏内容不够快，加载数据大屏界面产生了1-3s的白屏时间
   
   - 解决方案：首屏加载上，我使用动态路由的方式，来加载需要渲染的组件，在UI组件的使用上，我使用了按需加载的方式，最后我使用`localstorage`保存登录者的登录状态。数据大屏的加载上，因为请求的数量较多，产生了不可避免的白屏，所以我专门设计了一个加载界面，在请求全部加载完毕后，再显示数据大屏界面。
   
   - 额外拓展：我从骨架屏实现异步渲染组件上获得启发，实现一个请求全部加载完毕、再渲染界面的加载过程，首先实现了一个居中动态进度条，每请求到一个数据，进度条增加，然后界面左下角显示完成的请求消息以及请求花费的时间，最后在请求完成之后，用过渡的方式逐渐隐藏加载界面。

修正

主要体现在两个方面，一个是首屏加载的优化，另一个是数据大屏界面的加载优化。

首屏加载优化，我采用按需加载组件的方式，来最小体积化生成界面所需要的UI组件；另外在路由的配置上面，我采用组件懒加载的方式来生成对应路由下的界面，解决首屏加载时间过长的问题；另外在数据大屏界面的加载过程中，因为会产生一小段时间的白屏，那么我在用户体验的维度上，使用加载动画的方式，来提高用户的使用体验，具体是通过一个覆盖全屏的遮罩层、进度条以及加载信息的方式，来实现感知上的优化，在请求全部加载完毕之后，遮罩层渐进消失，展现数据大屏的所有内容

1. `pinia`的使用
   
   - 问题描述：在项目中，我需要管理子组件的数据状态、进行子组件之间的状态交互以及高效生成`echarts`的`option`对象
   
   - 解决方案：首先使用`pinia`的`state`来管理每个子组件的数据状态，考虑到每个子组件是唯一生成的而且组件层数只到第二层，我是使用最简单的`props`方式实现数据传递；子组件的状态是统一在代码仓库里进行管理的，所以像我项目里的全屏地图功能，就只需要控制`state`对应状态的变更，实现地图子组件的动态样式与其他子组件的显示样式；图表的数据已经存储在`state`当中，使用`getter`计算属性，生成`option`对象，再通过`props`传递给封装好的图表标签进行图表渲染。
   
   - 额外拓展：在`vue3`的开发环境下，项目里的组件传参除了使用`props`，还可以用`provide + inject`的方式进行数据传递，同时因为组件是唯一生成的，所以我还可以在子组件中直接使用状态管理对象，考虑到项目的可维护性，我认为把控项目的高可维护性比高性能更重要。地图子组件的全屏功能是一个频繁切换状态的功能，我使用`v-show`的方式控制其他子组件的显示样式，因为`v-if`与`v-show`相比，`v-if`会将这个DOM结点从DOM树上删除，造成不必要的浏览器性能损耗。因为`echarts`的原生实现是需要选择一个DOM对象，使用`echarts.init()`方法实例化图表，再使用`echarts.setOption()`方法传递`option`对象，完成图表渲染工作，实现代码不足够集成化、可维护性不好，所以使用`vue`封装好的图表库是一个很好的选择，我可以声明式地传递`option`对象、配置自动渲染、设置图表主题以及响应事件。我对比过`d3.js,hicharts.js`这类图表库，`d3`的图表生成需要很多的链式调用函数，虽然可以达到更深层次的掌控图表效果，但代码量大、可维护性不高；`hicharts`与`echarts`的实现设计基本一致，但是封装的图表库`vue-hicharts`不支持响应事件，功能集成上不完全，综合考虑，我最后使用`vue-echarts`来生成和展示图表。

修正

数据图表库的选型问题，`echarts`的原生实现是需要选择一个DOM对象，使用`init()`方法实例化图表，再使用`setOption()`方法传递`option`对象，最终完成图表渲染工作，但这样的话，代码量就显得比较多，整个实现过程也不成体系，造成不好维护的现象，所以我使用`vue`封装好的图表库来完成图表使用的工作，那么使用图表库的话，市面上有那么多成熟的图表库，我该选择哪一个呢？我主要筛选出三个还不错的库，分别是`d3.js`,`hicharts`,`echarts`，我得到的结果就是`d3.js`在实现上比较繁琐，需要花费一定的时间才能配置一张图表，同时图表的生成是过程化语言，而且还需要函数链式调用来生成图表对象，虽然生成的图表灵活性很高，但不利于我实现图表轻便、快速开发的需要||`hicharts`与`echarts`相比，在实现的思路上基本一致，但是封装的图表库`vue-hicharts`不支持响应事件，功能集成上相对不完全，所以综合考虑，我最后使用`vue-echarts`来生成和展示图表。

1. API的二次封装
   
   - 问题描述：在我的项目需要发起多个API请求、进行数据解析、对错误进行处理，简单实现API的请求，会造成代码冗余量大、项目可维护性不好
   
   - 解决方案：我考虑到API二次封装，就是为了将请求的整个过程模块化为基础配置、错误处理、请求创建、数据分析、请求描述，所以首先创建请求对象并进行基本配置，使用响应拦截器实现错误处理；其次是创建请求函数，返回请求对象的响应结果；最后在`pinia`的函数中以同步的方式进行使用，如果请求成功，就进行数据解析，拿到最后的数据并进行使用
   
   - 额外拓展：我将响应拦截器的错误处理封装成了一个函数，专门用于准确通知错误的类型、错误的消息；考虑到项目的可维护性，我将每一个请求函数都做了请求名称、使用参数、返回结果的文档性描述，方便我日后维护代码；

修正

API的二次封装，就是为了对请求的整个过程进行更好的管理，首先对请求头进行配置，使用请求拦截器获取`token`、进行逻辑判断、使用响应拦截器实现错误处理，生成的错误有不同的类型，根据不同的状态码来返回响应结果的说明，之后就是对每个请求编写一些文档注释，方便日后的请求接口维护。

---

4500 一个月，扣完五险一金 4000到手

封顶补贴12%

发24个月的收入（年终发年终奖，奖金发12个月）

公司提供房补、餐补

差不多每个月11k左右收入（11万左右、年薪10万8）
