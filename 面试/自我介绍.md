## 自我介绍

面试官你好，我叫刘坚，是一名前端开发工程师，接触前端开发有一年多的时间，目前是公司唯一的前端开发工程师，所有前端技术均是自学，技术栈是Vue全家桶，对Nuxt有简单了解和使用，我主导和参与的项目有数据大屏、批次管理系统、宿舍管理系统。

---

### 项目简介

数据大屏项目，这个项目用于展示公司销售相关的关键数据，给管理层提供一个直观、实时的界面，帮助管理层快速获取最新信息并作出有效的商业决策。主要使用的技术栈是`Vue全家桶+Echarts+Axios`

---

## 项目价值点

首先是首屏加载优化

1. 首屏加载优化，严格来说应该是加载优化
   
   - 问题描述：加载首屏内容不够快，加载数据大屏界面产生了1-3s的白屏时间
   
   - 解决方案：首屏加载上，我使用动态路由的方式，来加载需要渲染的组件，在UI组件的使用上，我使用了按需加载的方式，最后我使用`localstorage`保存登录者的登录状态。数据大屏的加载上，因为请求的数量较多，产生了不可避免的白屏，所以我专门设计了一个加载界面，在请求全部加载完毕后，再显示数据大屏界面。
   
   - 额外拓展：我从骨架屏实现异步渲染组件上获得启发，实现一个请求全部加载完毕、再渲染界面的加载过程，首先实现了一个居中动态进度条，每请求到一个数据，进度条增加，然后界面左下角显示完成的请求消息以及请求花费的时间，最后在请求完成之后，用过渡的方式逐渐隐藏加载界面。

2. `pinia`的使用
   
   - 问题描述：在项目中，我需要管理子组件的数据状态、进行子组件之间的状态交互以及高效生成`echarts`的`option`对象
   
   - 解决方案：首先使用`pinia`的`state`来管理每个子组件的数据状态，考虑到每个子组件是唯一生成的而且组件层数只到第二层，我是使用最简单的`props`方式实现数据传递；子组件的状态是统一在代码仓库里进行管理的，所以像我项目里的全屏地图功能，就只需要控制`state`对应状态的变更，实现地图子组件的动态样式与其他子组件的显示样式；图表的数据已经存储在`state`当中，使用`getter`计算属性，生成`option`对象，再通过`props`传递给封装好的图表标签进行图表渲染。
   
   - 额外拓展：在`vue3`的开发环境下，项目里的组件传参除了使用`props`，还可以用`provide + inject`的方式进行数据传递，同时因为组件是唯一生成的，所以我还可以在子组件中直接使用状态管理对象，考虑到项目的可维护性，我认为把控项目的高可维护性比高性能更重要。地图子组件的全屏功能是一个频繁切换状态的功能，我使用`v-show`的方式控制其他子组件的显示样式，因为`v-if`与`v-show`相比，`v-if`会将这个DOM结点从DOM树上删除，造成不必要的浏览器性能损耗。因为`echarts`的原生实现是需要选择一个DOM对象，使用`echarts.init()`方法实例化图表，再使用`echarts.setOption()`方法传递`option`对象，完成图表渲染工作，实现代码不足够集成化、可维护性不好，所以使用`vue`封装好的图表库是一个很好的选择，我可以声明式地传递`option`对象、配置自动渲染、设置图表主题以及响应事件。我对比过`d3.js,hicharts.js`这类图表库，`d3`的图表生成需要很多的链式调用函数，虽然可以达到更深层次的掌控图表效果，但代码量大、可维护性不高；`hicharts`与`echarts`的实现设计基本一致，但是封装的图表库`vue-hicharts`不支持响应事件，功能集成上不完全，综合考虑，我最后使用`vue-echarts`来生成和展示图表。

3. API的二次封装
   
   - 问题描述：在我的项目需要发起多个API请求、进行数据解析、对错误进行处理，简单实现API代码冗余量大、项目可维护性不好
   
   - 解决方案：我考虑到API二次封装，就是为了将请求的整个过程模块化为基础配置、错误处理、请求创建、数据分析、请求描述，所以首先创建请求对象并进行基本配置，使用响应拦截器实现错误处理；其次是创建请求函数，返回请求对象的响应结果；最后在`pinia`的函数中以同步的方式进行使用，如果请求成功，就进行数据解析，拿到最后的数据并进行使用
   
   - 额外拓展：我将响应拦截器的错误处理封装成了一个函数，专门用于准确通知错误的类型、错误的消息；考虑到项目的可维护性，我将每一个请求函数都做了请求名称、使用参数、返回结果的文档性描述，方便我日后维护代码；
