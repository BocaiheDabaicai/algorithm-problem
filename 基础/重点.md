# 渲染页面：浏览器的工作原理

影响web性能的两大原因

1. 等待资源加载

2. 单线程运行

#### 加载web页面的第一步：导航

1. DNS查询

网站地址会定位到对应的IP地址，再获取到web资源

如果是第一次访问网站，则需要查询DNS服务器，获取IP地址

如果网站里的每种资源都是一个网站地址，那么需要进行多次查询，才能定位所有资源的IP地址

2. TCP握手

浏览器通过TCP三次握手与服务器建立TCP连接

3. TLS协商

浏览器与服务器建立https安全连接，需要再进行一次握手，往返五次

#### 加载web页面的第二步：响应

1. 拥塞控制/TCP慢启动

TCP数据包会分成若干段进行传输，浏览器每接收到一个数据段，就需要发送ack给服务器

为了在网络通畅时尽可能增加传输段数量、网络拥堵时尽可能减少传输段数量，就使用CWND(拥塞窗口)控制传输段数量，CWND越大，传输段数量越大

收到ACK之后，CWND会加倍；没有收到ACK，CWND会减半

#### 加载web页面的第三步：解析

1. 构建DOM树

获取HTML标签，并解析为DOM树

CSS文件、图片资源不会阻碍解析过程，脚本标签需要注意

2. 预加载扫描器

扫描预加载资源（图片、脚本等等），同时防止js无法读取DOM元素及CSS样式

3. 构建CSSOM树

一棵独立的树，用于映射DOM树上每个元素所使用的样式

构建快速，总时间小于一次DNS查询时间

4. 其他过程 

js会在树构建的过程中，进行资源下载；脚本会被解析为抽象语法树，输入编译器、输出字节码（JS编译）

构建AOM，支持屏幕阅读器访问浏览器内容（构建无障碍树）

#### 加载web页面的第四步：渲染

将解析得到的DOM树和CSSOM树合成一颗渲染树，再计算每个元素的布局，并绘制到屏幕上

样式，使用`display:none`的样式不会包含在渲染树中，使用`visibility:hidden`会包含在渲染树中

布局，计算出渲染树中所有结点占用的高度、宽度、位置，以及确定每个对象的大小和位置

> 回流：对页面的任何部分或整个文档后续大小和位置的确认

第一次计算大小及位置称为布局，后续计算称为回流

绘制，使用屏幕上的每一个像素点渲染结点

合成，不同层次发生重叠，需要确保它们以正确的顺序进行内容显示

#### 加载web页面的第五步：交互

界面被绘制成功之前，需要等待JS完成执行，尽可能不要让JS占用主线程，阻碍界面的渲染工作

#### 总结

渲染页面

先进行导航，获取网站地址，并转换成IP地址

再进行TCP连接，完成请求前的配置

再获取响应数据

进行页面数据解析，并生成DOM树、CSSOM树、语法抽象树、AOM无障碍树

再进行渲染工作，先将DOM树、CSSOM树合成一颗渲染树，并在设备上完成节点布局，最后进行界面绘制

最后，脚本完成加载、解析、执行工作，实现界面交互

> 文档的各个部分以不同层绘制，这个层指的是什么？

---

# 盒模型

#### 块级盒子和内联盒子

块级盒子

- 内联方向上占据父元素的所有可用空间

- 每个盒子会换行

- 宽、高属性会生效

- 内外边距、边框会把其他元素从当前盒子周围推开

内联盒子

- 盒子不会换行

- 宽、高属性不生效

- 垂直方向的内外边距、边框可以使用，但不会推开其它内联盒子

- 水平方向的内外边距、边框可以使用，会推开其它内联盒子

#### 内部和外部显示类型

通过设置`display:inline/block`可以设置元素的外部显示类型

如果设置`display:flex`可以将当前元素设置为块级盒子，同时内部的直接子元素会被设置为`flex`元素

> 正常文档流：盒子的默认布局样式
> 
> 外边距折叠：垂直方向上，两个相邻的元素都设置了外边距，而且相接触，那么更大的外边距会被保留

#### 不同显示类型的例子

主要是`display:inline-flex`，这个设置表示外部显示类型为内联元素，内部的直接子元素被设置为`flex`元素

#### 什么是CSS盒模型

标准盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由 边框+内边距+内容区域 组成

内容宽度、高度 由 `width + height` 组成

> 标准盒模型的宽度、高度表示内容区域的宽度、高度

替代盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由  `width + height` 组成

内容宽度、高度 由 `width + height` - 边框 - 内边距 组成

> 替代盒模型的宽度、高度表示 边框+内边距+内容区域 的和

#### 玩转盒模型

调试工具可以查看盒模型

### 外边距，内边距，边框

三个盒子属性，`margin`,`padding`,`border`

### 盒子模型和内联盒子

内联盒子

外边距、边框、内边距的属性设置会生效，但宽、高度属性无法生效，可能会产生元素重叠

内联块盒子（`display:"inline-block"`）

外边距、边框、内边距以及宽、高度的设置会生效，但外部显示属性为内联盒子

### 使用`display:inline-block`属性

---

# 原型链与原型对象

原型：当前对象身上的一个属性，用于指向另一个对象

原型链：从第一个对象的原型开始，到原型的值为`null`为止

### 基于原型链的继承

`someObject.[[Prototype]]`用于标识`someObject`的原型属性

原型属性的访问方式

- 标准规范方式，`someObject.[[Prototype]]`

- 对象方法，`object.getPrototypeOf(someObject)`、`object.setPrototypeOf()`

- 尽量避免，`obj.__proto__`，因为这是非标准的访问方式

原型在对象属性中的表现形式`{...,__proto__:anoObject}`

> 属性遮蔽：当前对象和原型对象都有相同的属性，那么对象属性的访问会发生在当前对象上

继承：设置当前对象的原型指向另一个对象

继承方法：该方法出现在原型链的某个对象上，从当前对象开始寻找，同时对其它属性值的使用，会在函数寻找成功后，再从当前对象开始寻找，并使用函数

构造函数：使用本身设置属性的函数

`new`：使构造函数获取内置对象的实例

构造函数的使用：

```js
// 1. 构造函数 创建实例对象
function Box(value){
    this.value = value
}

Box.prototype.getValue = function(){
    return this.value
}

let a = new Box(2)
// 2. class语法糖 创建实例对象
class Box{
    constructor(value){
        this.value = value
    }
    getValue(){
        return this.value
    }
}
```

重新赋值，对原型对象的属性进行再次修改

- 所有实例对象在引用该属性时发生改变

- 如果只单独改变一个实例对象，那么在这个实例的构造函数上添加同名方法（继承）

`class`语法糖的理解

- `constructor`：属性配置在构造函数对象上

- `class`作用域：除`constructor`以外的函数方法，属性配置在构造对象的原型对象上

字面量的隐式构造函数

声明 `const a = {val:1} , b = [1,2,3]`等变量，这些变量会自动使用对应的原型对象

如果需要明确使用对应的原型对象，那么使用`new`关键字，配上对应的数据类型`Array`...

> 需要避免发生的错误：
> 
> 猴子修补：直接在现有的数据类型的原型对象上添加新方法，这可能会导致后续向前兼容的风险
> 
> `constructor`：
> 
> 这是一个引用构造函数本身的属性，`javascript`对象自有属性

扩展原型链

- 标准的方法，`Object.setPrototypeOf(构造函数的原型对象,需要继承的构造函数的原型对象)`

- `class`语法糖，`class Box extends Shape {}`

> `Object.create()`不推荐使用，使用这个方法对原型对象重新赋值会删除`constructor`属性

### 检查原型：更深入的研究

寻找属性

- 构造函数的实例对象会触发链式寻找，访问原型链

- 构造函数不会触发链式寻找

- 构造函数的原型对象会触发链式寻找

### 使用不同的方法来创建对象和改变原型链

语法结构创建对象，与字面量的隐式构造相同

构造函数创建对象，极好的方式，构造函数的函数方法放在构造函数的原型对象上

`Object.create()`创建对象，不支持IE8及以下的版本、同时会删除原型对象上的`constructor`属性

使用类创建对象，不支持旧环境，可读性非常好

> 类继承中使用
> 
> `super()`：会引用父类的构造函数，可以传递参数

`Object.setprototypeOf()`改变原型链，不支持IE8及以下版本

### 结论

1. 所有构造函数实例对象的原型对象相同，构造函数与实例对象的原型对象相同

2. 永远不要扩展原生原型，除非是为了兼容JS新特性
