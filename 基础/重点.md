# 渲染页面：浏览器的工作原理

影响web性能的两大原因

1. 等待资源加载

2. 单线程运行

#### 加载web页面的第一步：导航

1. DNS查询

网站地址会定位到对应的IP地址，再获取到web资源

如果是第一次访问网站，则需要查询DNS服务器，获取IP地址

如果网站里的每种资源都是一个网站地址，那么需要进行多次查询，才能定位所有资源的IP地址

2. TCP握手

浏览器通过TCP三次握手与服务器建立TCP连接

3. TLS协商

浏览器与服务器建立https安全连接，需要再进行一次握手，往返五次

#### 加载web页面的第二步：响应

1. 拥塞控制/TCP慢启动

TCP数据包会分成若干段进行传输，浏览器每接收到一个数据段，就需要发送ack给服务器

为了在网络通畅时尽可能增加传输段数量、网络拥堵时尽可能减少传输段数量，就使用CWND(拥塞窗口)控制传输段数量，CWND越大，传输段数量越大

收到ACK之后，CWND会加倍；没有收到ACK，CWND会减半

#### 加载web页面的第三步：解析

1. 构建DOM树

获取HTML标签，并解析为DOM树

CSS文件、图片资源不会阻碍解析过程，脚本标签需要注意

2. 预加载扫描器

扫描预加载资源（图片、脚本等等），同时防止js无法读取DOM元素及CSS样式

3. 构建CSSOM树

一棵独立的树，用于映射DOM树上每个元素所使用的样式

构建快速，总时间小于一次DNS查询时间

4. 其他过程 

js会在树构建的过程中，进行资源下载；脚本会被解析为抽象语法树，输入编译器、输出字节码（JS编译）

构建AOM，支持屏幕阅读器访问浏览器内容（构建无障碍树）

#### 加载web页面的第四步：渲染

将解析得到的DOM树和CSSOM树合成一颗渲染树，再计算每个元素的布局，并绘制到屏幕上

样式，使用`display:none`的样式不会包含在渲染树中，使用`visibility:hidden`会包含在渲染树中

布局，计算出渲染树中所有结点占用的高度、宽度、位置，以及确定每个对象的大小和位置

> 回流：对页面的任何部分或整个文档后续大小和位置的确认

第一次计算大小及位置称为布局，后续计算称为回流

绘制，使用屏幕上的每一个像素点渲染结点

合成，不同层次发生重叠，需要确保它们以正确的顺序进行内容显示

#### 加载web页面的第五步：交互

界面被绘制成功之前，需要等待JS完成执行，尽可能不要让JS占用主线程，阻碍界面的渲染工作

#### 总结

渲染页面

先进行导航，获取网站地址，并转换成IP地址

再进行TCP连接，完成请求前的配置

再获取响应数据

进行页面数据解析，并生成DOM树、CSSOM树、语法抽象树、AOM无障碍树

再进行渲染工作，先将DOM树、CSSOM树合成一颗渲染树，并在设备上完成节点布局，最后进行界面绘制

最后，脚本完成加载、解析、执行工作，实现界面交互

> 文档的各个部分以不同层绘制，这个层指的是什么？

---

# 盒模型

#### 块级盒子和内联盒子

块级盒子

- 内联方向上占据父元素的所有可用空间

- 每个盒子会换行

- 宽、高属性会生效

- 内外边距、边框会把其他元素从当前盒子周围推开

内联盒子

- 盒子不会换行

- 宽、高属性不生效

- 垂直方向的内外边距、边框可以使用，但不会推开其它内联盒子

- 水平方向的内外边距、边框可以使用，会推开其它内联盒子

#### 内部和外部显示类型

通过设置`display:inline/block`可以设置元素的外部显示类型

如果设置`display:flex`可以将当前元素设置为块级盒子，同时内部的直接子元素会被设置为`flex`元素

> 正常文档流：盒子的默认布局样式
> 
> 外边距折叠：垂直方向上，两个相邻的元素都设置了外边距，而且相接触，那么更大的外边距会被保留

#### 不同显示类型的例子

主要是`display:inline-flex`，这个设置表示外部显示类型为内联元素，内部的直接子元素被设置为`flex`元素

#### 标准盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由 边框+内边距+内容区域 组成

内容宽度、高度 由 `width + height` 组成

#### 替代盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由  `width + height` 组成

内容宽度、高度 由 `width + height` - 边框 - 内边距 组成


