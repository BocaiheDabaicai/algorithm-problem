# 渲染页面：浏览器的工作原理

影响web性能的两大原因

1. 等待资源加载

2. 单线程运行

#### 加载web页面的第一步：导航

1. DNS查询

网站地址会定位到对应的IP地址，再获取到web资源

如果是第一次访问网站，则需要查询DNS服务器，获取IP地址

如果网站里的每种资源都是一个网站地址，那么需要进行多次查询，才能定位所有资源的IP地址

2. TCP握手

浏览器通过TCP三次握手与服务器建立TCP连接

3. TLS协商

浏览器与服务器建立https安全连接，需要再进行一次握手，往返五次

#### 加载web页面的第二步：响应

1. 拥塞控制/TCP慢启动

TCP数据包会分成若干段进行传输，浏览器每接收到一个数据段，就需要发送ack给服务器

为了在网络通畅时尽可能增加传输段数量、网络拥堵时尽可能减少传输段数量，就使用CWND(拥塞窗口)控制传输段数量，CWND越大，传输段数量越大

收到ACK之后，CWND会加倍；没有收到ACK，CWND会减半

#### 加载web页面的第三步：解析

1. 构建DOM树

获取HTML标签，并解析为DOM树

CSS文件、图片资源不会阻碍解析过程，脚本标签需要注意

2. 预加载扫描器

扫描预加载资源（图片、脚本等等），同时防止js无法读取DOM元素及CSS样式

3. 构建CSSOM树

一棵独立的树，用于映射DOM树上每个元素所使用的样式

构建快速，总时间小于一次DNS查询时间

4. 其他过程 

js会在树构建的过程中，进行资源下载；脚本会被解析为抽象语法树，输入编译器、输出字节码（JS编译）

构建AOM，支持屏幕阅读器访问浏览器内容（构建无障碍树）

#### 加载web页面的第四步：渲染

将解析得到的DOM树和CSSOM树合成一颗渲染树，再计算每个元素的布局，并绘制到屏幕上

样式，使用`display:none`的样式不会包含在渲染树中，使用`visibility:hidden`会包含在渲染树中

布局，计算出渲染树中所有结点占用的高度、宽度、位置，以及确定每个对象的大小和位置

> 回流：对页面的任何部分或整个文档后续大小和位置的确认

第一次计算大小及位置称为布局，后续计算称为回流

绘制，使用屏幕上的每一个像素点渲染结点

合成，不同层次发生重叠，需要确保它们以正确的顺序进行内容显示

#### 加载web页面的第五步：交互

界面被绘制成功之前，需要等待JS完成执行，尽可能不要让JS占用主线程，阻碍界面的渲染工作

#### 总结

渲染页面

先进行导航，获取网站地址，并转换成IP地址

再进行TCP连接，完成请求前的配置

再获取响应数据

进行页面数据解析，并生成DOM树、CSSOM树、语法抽象树、AOM无障碍树

再进行渲染工作，先将DOM树、CSSOM树合成一颗渲染树，并在设备上完成节点布局，最后进行界面绘制

最后，脚本完成加载、解析、执行工作，实现界面交互

> 文档的各个部分以不同层绘制，这个层指的是什么？

---

# 盒模型

#### 块级盒子和内联盒子

块级盒子

- 内联方向上占据父元素的所有可用空间

- 每个盒子会换行

- 宽、高属性会生效

- 内外边距、边框会把其他元素从当前盒子周围推开

内联盒子

- 盒子不会换行

- 宽、高属性不生效

- 垂直方向的内外边距、边框可以使用，但不会推开其它内联盒子

- 水平方向的内外边距、边框可以使用，会推开其它内联盒子

#### 内部和外部显示类型

通过设置`display:inline/block`可以设置元素的外部显示类型

如果设置`display:flex`可以将当前元素设置为块级盒子，同时内部的直接子元素会被设置为`flex`元素

> 正常文档流：盒子的默认布局样式
> 
> 外边距折叠：垂直方向上，两个相邻的元素都设置了外边距，而且相接触，那么更大的外边距会被保留

#### 不同显示类型的例子

主要是`display:inline-flex`，这个设置表示外部显示类型为内联元素，内部的直接子元素被设置为`flex`元素

#### 什么是CSS盒模型

标准盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由 边框+内边距+内容区域 组成

内容宽度、高度 由 `width + height` 组成

> 标准盒模型的宽度、高度表示内容区域的宽度、高度

替代盒模型

一种盒子的模型，包含外边距、边框、内边距、内容区域

盒子宽度和高度 由  `width + height` 组成

内容宽度、高度 由 `width + height` - 边框 - 内边距 组成

> 替代盒模型的宽度、高度表示 边框+内边距+内容区域 的和

#### 玩转盒模型

调试工具可以查看盒模型

### 外边距，内边距，边框

三个盒子属性，`margin`,`padding`,`border`

### 盒子模型和内联盒子

内联盒子

外边距、边框、内边距的属性设置会生效，但宽、高度属性无法生效，可能会产生元素重叠

内联块盒子（`display:"inline-block"`）

外边距、边框、内边距以及宽、高度的设置会生效，但外部显示属性为内联盒子

### 使用`display:inline-block`属性

---

# 原型链与原型对象

原型：当前对象身上的一个属性，用于指向另一个对象

原型链：从第一个对象的原型开始，到原型的值为`null`为止

### 基于原型链的继承

`someObject.[[Prototype]]`用于标识`someObject`的原型属性

原型属性的访问方式

- 标准规范方式，`someObject.[[Prototype]]`

- 对象方法，`object.getPrototypeOf(someObject)`、`object.setPrototypeOf()`

- 尽量避免，`obj.__proto__`，因为这是非标准的访问方式

原型在对象属性中的表现形式`{...,__proto__:anoObject}`

> 属性遮蔽：当前对象和原型对象都有相同的属性，那么对象属性的访问会发生在当前对象上

继承：设置当前对象的原型指向另一个对象

继承方法：该方法出现在原型链的某个对象上，从当前对象开始寻找，同时对其它属性值的使用，会在函数寻找成功后，再从当前对象开始寻找，并使用函数

构造函数：使用本身设置属性的函数

`new`：使构造函数获取内置对象的实例

构造函数的使用：

```js
// 1. 构造函数 创建实例对象
function Box(value){
    this.value = value
}

Box.prototype.getValue = function(){
    return this.value
}

let a = new Box(2)
// 2. class语法糖 创建实例对象
class Box{
    constructor(value){
        this.value = value
    }
    getValue(){
        return this.value
    }
}
```

重新赋值，对原型对象的属性进行再次修改

- 所有实例对象在引用该属性时发生改变

- 如果只单独改变一个实例对象，那么在这个实例的构造函数上添加同名方法（继承）

`class`语法糖的理解

- `constructor`：属性配置在构造函数对象上

- `class`作用域：除`constructor`以外的函数方法，属性配置在构造对象的原型对象上

字面量的隐式构造函数

声明 `const a = {val:1} , b = [1,2,3]`等变量，这些变量会自动使用对应的原型对象

如果需要明确使用对应的原型对象，那么使用`new`关键字，配上对应的数据类型`Array`...

> 需要避免发生的错误：
> 
> 猴子修补：直接在现有的数据类型的原型对象上添加新方法，这可能会导致后续向前兼容的风险
> 
> `constructor`：
> 
> 这是一个引用构造函数本身的属性，`javascript`对象自有属性

扩展原型链

- 标准的方法，`Object.setPrototypeOf(构造函数的原型对象,需要继承的构造函数的原型对象)`

- `class`语法糖，`class Box extends Shape {}`

> `Object.create()`不推荐使用，使用这个方法对原型对象重新赋值会删除`constructor`属性

### 检查原型：更深入的研究

寻找属性

- 构造函数的实例对象会触发链式寻找，访问原型链

- 构造函数不会触发链式寻找

- 构造函数的原型对象会触发链式寻找

### 使用不同的方法来创建对象和改变原型链

语法结构创建对象，与字面量的隐式构造相同

构造函数创建对象，极好的方式，构造函数的函数方法放在构造函数的原型对象上

`Object.create()`创建对象，不支持IE8及以下的版本、同时会删除原型对象上的`constructor`属性

使用类创建对象，不支持旧环境，可读性非常好

> 类继承中使用
> 
> `super()`：会引用父类的构造函数，可以传递参数

`Object.setprototypeOf()`改变原型链，不支持IE8及以下版本

### 结论

1. 所有构造函数实例对象的原型对象相同，构造函数与实例对象的原型对象相同

2. 永远不要扩展原生原型，除非是为了兼容JS新特性

---

# JavaScript运行机制

js 是一门单线程语言

### javaScript执行上下文

执行上下文一共有三种类型：

1. 全局上下文，执行除函数以外的所有js代码

2. 函数上下文，执行函数作用域内的代码

3. `eval()`函数，尽量少使用

执行顺序

- 首先全局上下文被推入执行上下文栈，并进行执行

- 执行到函数，那么创建该函数的执行上下文，并推入栈中进行执行

- 函数的执行上下文执行结束，推出执行上下文栈

- 函数的执行上下文全部执行完毕，全局上下文继续执行

- 所有代码全部执行完毕之后，全局上下文推出栈，运行结束

> 如果函数在执行中，出现调用其它函数，那么为该函数创建执行上下文再推入栈，并在该函数执行完毕之后，再推出栈
> 
> 递归会为函数自身创建新的执行上下文进行执行

### javaScript运行时

`javascript`运行时维护了用于执行js代码的代理

代理的组成：

- 执行上下文集合、执行上下文栈、主线程

- 执行`worker`的额外线程集合、任务队列、微任务队列

事件循环

它是一种机制，每个代理由事件循环进行驱动，完成收集事件、对任务进行排队

执行过程：处于等待中的`javascript`任务、微任务、进行必要的渲染和绘制

任务与微任务

    任务是指由标准机制执行的`JavaScript`

任务队列与微任务队列的运行

- 任务队列，事件循环开始迭代时，执行队列中的每个任务，执行过程中添加的任务需要等待下一次事件循环的迭代

- 微任务队列，当一个任务退出且执行上下文栈为空时，微任务队列的每一个微任务依次执行，即是新增加微任务，也会在这次事件循环中得到执行

`setTimeOut(func,second)`：该函数会等待消息队列里的任务全部执行后，再进入执行上下文栈进行执行，`second`参数只是描述延时函数的最小等待时间

---

# Vite与WebPack的区别

`vite`：轻量级的打包工具，使用原生浏览器的加载功能，实现开发环境中代码的快速重载与构建，打包上实现保存缓存文件，第一次打包后，只更新修改的内容

`webpack`：适合大型、复杂的项目，可配置性、灵活性很高，每次修改代码需要对整个项目重新编译

---

# 内存管理

### 垃圾回收机制

当对象没有被其他对象引用之后，就会被回收内存

> 对于一个有多个属性的对象来说，需要保证对象本身以及对象的每个属性都没有被引用，才会被垃圾回收机制进行回收

现代浏览器主要使用标记-清除算法扫描需要清除的对象

从根对象开始，不断遍历根对象引用的对象，找出所有有引用的对象和没有引用的对象，并将没有引用的对象进行回收处理

即便是函数作用域里循环引用的对象，如果从根对象开始寻找，没有找到就会被回收

---

# 闭包

内部作用域调用外部作用域

闭包由词法环境与函数作用域组成，本质上就是为了实现数据隐藏与封装

---

# JavaScript 的相等性判断

`==`：宽松相等，比较两个操作数之间的数值是否相等（NaN之间不相等、-0 与 +0相等）

`===`：严格相等，比较两个操作数之间的数据类型、数据值是否相等（NaN之间不相等、-0 与 +0相等）

`Object.is()`：对象方法，比较两个操作数之间的数值是否相等，不做类型转换、不比较数据类型（NaN之间相等、-0 与 +0不相等）

---

# Promise

执行上下文栈的执行顺序：

1. 全局作用域下的调用函数，包括`new Promise`的执行体内容，`结果内容resolve`作为微任务处理

2. 执行上下文栈完全为空之后，开始按顺序执行`setTimeOut`函数

执行的内容：

1. 调用函数

2. 异步函数、`Promise`

3. IIFE(立即调用函数表达式)

4. `queueMicrotask()`，创建微任务

5. `setTimeOut`，时间函数

首先执行 IIFE

然后从上往下 依次执行代码

- 调用普通函数

- `Promise`对象体会执行，但解决后的内容会放进微任务队列

- 使用`queueMicrotask`，会将内部的执行体放入微任务队列

> 特别提示，在异步函数当中使用`await`，使用`await`表达式后面的内容会被放入微任务队列进行执行（仅限在同一个函数作用域下），如果外层还有作用域，那么会将以外的内容作为一个闭包等待前面的内容执行完毕

异步编程发展历程：

1. 回调函数，在请求成功后的作用域进行操作，产生回调地狱现象

2. `promise`，直接返回已解决或被拒绝的结果，链式调用不断传递解决结果

3. `generator`，按顺序执行`yield`内容

4. `async,await`，同步执行请求，`await`返回`Promise.resolve`的结果，如果出错需要捕获

---

# This

`this`的使用取决于它的上下文

1. 函数上下文，`this`就指向函数本身，箭头函数里`this`指向`globalThis`对象，如果嵌套函数中使用箭头函数，那么箭头函数中的`this`会指向上一级函数对象，构造函数里，可以使用`this`为函数设置属性

2. 类上下文中，`super`会指向父类的构造器，`this`指向类本身

3. 全局上文中，`this`会指向`globalThis`对象

`call,apply,bind`的认识

将当前函数的`this`设定为另一个对象

1. `call`，接收一个对象，后续的参数为函数的参数，立即执行函数

2. `apply`，接受一个对象，后续的参数为数组，数组里的每一项为函数的参数，立即执行函数

3. `bind`，接收一个对象，后续的参数为函数的参数，返回一个执行函数
