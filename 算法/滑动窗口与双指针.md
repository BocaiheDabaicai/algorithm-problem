### 循环不变量

循环前、中、后，数据值不变

### 删除有序数组中的重复项

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
返回 k 。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owkrrm/
来源：力扣（LeetCode）

解题

```js
var removeDuplicates = function(nums) {
    let len = nums.length
    if(len < 2) return len

    let i = 0
    for(let j=1;j<len;j++){
        if(nums[j] !== nums[i]){
            i++
            nums[i] = nums[j]
        }
    }

    return i+1
};
```

### 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/rl0ncs/
来源：力扣（LeetCode）

解题

```js
var findLengthOfLCIS = function(nums) {
    let res= 0
    let i = 0
    let j =0

    while(j < nums.length){
        if(j > 0 && nums[j-1] >= nums[j]){
            i = j
        }
        j++
        res = Math.max(res,j-i)
    }

    return res
};
```

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owzh97/
来源：力扣（LeetCode）

解题

```js
var removeElement = function(nums, val) {
    let len = nums.length
    let i =0
    let j = 0
    let res = 0

    while(i<len){
        if(nums[i] === val){
            j = i + 1
            while(nums[j] === val) j++
            if(j<nums.length){
                let temp = nums[i]
                nums[i] = nums[j]
                nums[j] = temp
                res++
            }
        }else res ++
        i++
    }

    return res
};
```

### 删除排序数组中的重复项 II

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/owzb55/
来源：力扣（LeetCode）

```js
var removeDuplicates = function(nums) {
    let len = nums.length
    if(len < 2) return len

    let slow = 2
    for(let fast = 2;fast<len;fast++){
        if(nums[fast]!==nums[slow-2]){
            nums[slow] = nums[fast]
            slow++
        }
    }

    return slow
};
```

### 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

解题

```js
var moveZeroes = function(nums) {
    let len = nums.length
    if(len < 2) return len

    let left = 0

    for(let i=0;i<len;i++){
        if(nums[i] !== 0){
            nums[left++] = nums[i]
            if(i >= left) nums[i] = 0
        }
    }

};
```

---

### 使用循环不变量写对代码

### 颜色分类

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/rllo1h/
来源：力扣（LeetCode）

```js
var sortColors = function(nums) {
    let len = nums.length
    let i = 0
    let zero = 0

    while(i<len){
        if(nums[i] === 0){
            swap(nums,i,zero)
            i++
            zero++
        }else if(nums[i] === 1){
            i++
        }else{
            len--
            swap(nums,i,len)
        }
    }
};

const swap = function(nums,i,j){
    let temp = nums[i]
    nums[i] = nums[j]
    nums[j] = temp
}
```

### 数组中的第 K 个最大元素（第二次）

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/sliding-window-and-two-pointers/rlifzm/
来源：力扣（LeetCode）

```js

```
