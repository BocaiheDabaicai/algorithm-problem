# 递归与分治

### Pow(x,n)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

```js
 var myPow = function(x,n){
     return Math.pow(x,n)
 }

var myPow = function(x, n) {
    if(n>0) return multiply(x,n)
    else if(n<0) return multiply(1/x,-n)
    else return 1
};

var multiply = function(x,n){
    if(n === 1){
        return x
    }

    return x * multiply(x,n-1)
}
```

### 递归乘法

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。

```js
var multiply = function(A, B) {
    return add(A,B)
};
var add = function(a,b){
    if(b === 1) return a

    return a + add(a,b-1)
}
```

### <u>计算右侧小于当前元素的个数</u>

给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/recursion-and-divide-and-conquer/rn0aht/
来源：力扣（LeetCode）

解题

```js
var countSmaller = function(nums) {
    let count = 0
    let arr = [], uArr = nums

    for(let i=0;i<uArr.length;i++){
        if(i > 0 && nums[i] === nums[i-1]) arr.push(arr[i-1])
        else{
            for(let j=i+1;j<uArr.length;j++)
                if(uArr[j] < uArr[i]) count++
            arr.push(count)
            count = 0
        }
    }

    return arr
};
```

> 66个用例，只通过63个用例


