# 字节跳动的高频算法

### 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

解题

```js
var lengthOfLongestSubstring = function(s) {
    let arr = Array.from({length:128},()=>0)
    let slow = fast = res = 0

    while(fast < s.length){
        arr[s.charCodeAt(fast)] ++
        while(arr[s.charCodeAt(fast)]>1) {
            arr[s.charCodeAt(slow)] --
            res = Math.max(res,fast - slow)
            slow++
        }
        fast++
    }
    res = Math.max(res,fast - slow)

    return res
};
```

### 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

解题

```js
// 中心奇偶回文
var longestPalindrome = function(s) {
    let i = j = 0

    for(let k=1;k<s.length;k++){
        let i0 = j0 = k
        while(i0>0 && j0<s.length-1){
            if(s[i0-1] === s[j0+1]){
                i0 --
                j0 ++
            }else break
        }
        if(j0 - i0 > j - i){
            j = j0 
            i = i0 
        }

        i0 = k,j0 = k-1
        while(i0>0 && j0<s.length-1){
            if(s[i0-1] === s[j0+1]){
                i0 --
                j0 ++
            }else break
        }
        if(j0 - i0 > j - i){
            j = j0 
            i = i0 
        }
    }

    return s.slice(i,j+1)
};
```

### 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

解题

```js
// 递归沉岛
var numIslands = function(grid) {
    let count = 0

    let sink = function(row,col){
        if(row < 0 || row >= grid.length) return
        if(col < 0 || col >= grid[0].length) return
        if(grid[row][col] === "0") return
        grid[row][col] = "0"

        sink(row - 1,col)
        sink(row + 1,col)
        sink(row,col - 1)
        sink(row,col + 1)
    }

    for(let row=0;row<grid.length;row++)
        for(let col=0;col<grid[0].length;col++){
            if(grid[row][col] === "1") {
                count++
                sink(row,col)
            }
        }

    return count
};
```

## K 个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

解题

```js
var reverseKGroup = function(head, k) {
    let i = 0
    let slow = fast = head, newHead = new ListNode()
    let np = newHead

    while(fast){
        i++
        fast = fast.next
        if(i === k){
            let tmp = reverse(slow,fast)
            np.next = tmp
            while(tmp.next) tmp = tmp.next
            np = tmp
            i = 0
            slow = fast
        }
    }
    np.next = slow
    return newHead.next
};

function reverse(slow,fast){
    let p = slow, pre = null
    while(p !== fast){
        const tmp = p.next
        p.next = pre
        pre = p
        p = tmp
    }
    return pre
}
```


