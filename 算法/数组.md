#### 集合

一组东西组合在一起，没有顺序、没有固定的类型

#### 列表

同种类型的数据项构成的有顺序、长度可变的集合

#### 数组

有索引的列表，每个数据项逻辑地址相邻、物理地址相邻

| 名称  | 顺序  | 类型  | 长度  | 索引  |
| --- | --- | --- | --- | --- |
| 集合  | 无   | 不固定 | 可变  | 无   |
| 列表  | 有   | 固定  | 可变  | 无   |
| 数组  | 有   | 固定  | 可变  | 有   |

---

#### 元素读取

计算机为数组申请一段内存地址连续的空间，并使索引`0`的位置指向第一个元素的内存地址，通过访问索引值，一次查找，实现获取对应内存地址下的元素值

#### 元素查找

从头开始，依次遍历

#### 元素插入

首尾插入、内部插入，数组中内部插入，其后元素会腾出空间，造成时间浪费

#### 元素删除

首尾删除、内部删除，数组内部删除元素，其后元素会向前挪动，耗费时间

---

#### 寻找数组的中心索引

题目介绍：

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/yf47s/
来源：力扣（LeetCode）

```js
var pivotIndex = function(nums) {
    let sum = 0;
    sum = nums.reduce((acc,cur) => acc+cur,0);
    let sum_left = 0;
    for(let i=0;i<nums.length;i++){
        sum -= nums[i];
        if(sum_left === sum) return i;
        sum_left += nums[i]
    } 
    return -1;
};
```

解释：

先获取数组的和

从数组的首位开始，获取当前位置的值，总和中去掉当前位置的值

判断左侧总和是否与总和相等，相等，返回当前下标；不相等，左侧总和加上这个当前值

如果遍历完成，则返回-1

#### 搜索插入位置

题目介绍：

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/cxqdh/
来源：力扣（LeetCode）

```js
var searchInsert = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    while(left <= right){
        let mid = left + Math.trunc((right - left) / 2)
        if(target > nums[mid]) left = mid + 1
        else if(target < nums[mid]) right = mid - 1
        else return mid
    }
    return left
};
// for(let i=0;i<nums.length;i++){
//     if(target <= nums[i]) return i
// }
// return nums.length
```

解析：

二分法查找，直到左坐标大于右坐标时，返回当前的左坐标

获取中间位置要防止数组溢出

使用`let mid = left + Math.trunc((right - left) / 2)`

#### 合并区间

题目介绍：

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/c5tv3/
来源：力扣（LeetCode）

```js
var merge = function(intervals) {
    intervals = intervals.sort((min,max) => min[0] - max[0]);

    for(let index=0;index<intervals.length;) {
        if(intervals[index + 1] && intervals[index][1] >= intervals[index + 1][0]) {
            let left = Math.min(intervals[index][0],intervals[index + 1][0])
            let right = Math.max(intervals[index][1],intervals[index + 1][1])
            intervals.splice(index,2,[left,right])
        }else{
            index++
        }
    };

    return intervals
};
```

解析：

先将数组排序

当前位置的后一个数组存在且当前元素的第一个值比后一个元素的第0个值大，

找出这两个数组的最小值、最大值，并插入当前位置，且移除两个元素

如果条件不成立，指数加一（实现合并后的元素继续进行判断）

最后返回结果

---

#### 二维数组

它是一种结构较为特殊的数组，内部存放的元素是数组

#### 旋转矩阵

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

```js
var rotate = function(matrix) {
    let result = []
    for(let i = 0;i<matrix.length;i++){
        let row = []
        for(let j = 0;j<matrix[i].length;j++){
            row.unshift(matrix[j][i])
        }
        result.push(row)
    }
    matrix.splice(0,matrix.length,...result)
};
```

解析：

不占用空间，先进行上下交换，在进行对角交换

JS巧解，每列元素逆向插入并收集，使用`splice`方法以模板字符串的方式替换所有元素

#### 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

```js
var setZeroes = function(matrix) {
    let zeroRow = []
    let zeroCol = []
    for(let i=0;i<matrix.length;i++){
        for(let j=0;j<matrix[i].length;j++){
            if(matrix[i][j] === 0) {
                zeroRow.push(i)
                zeroCol.push(j)
            }
        }
    }
    zeroRow.forEach(item => {
        for(let j=0;j<matrix[0].length;j++)
            matrix[item][j] = 0
    })
    zeroCol.forEach(item => {
        for(let i=0;i<matrix.length;i++)
            matrix[i][item] = 0
    })
};
```

解析：

先找到需要修改为0的行和列

遍历需修改的行和列，将每个值修改为0

#### 对角线遍历

给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

```js
var findDiagonalOrder = function(mat) {
    let result = []
    let flap = []
    let tag = 0
    for(let i=0;i<mat.length;i++){
        for(let j=0;j<mat[i].length;j++)
            result.push({value:mat[i][j],row:i,col:j})
    }
    
    for(let t=0;t<result.length;t++){
        let row = []
        for(let i=0;i<result.length;i++){
            if(tag === result[i].row + result[i].col){
                row.push(result[i].value)
            }
        }
        if(tag % 2 === 0) row = row.reverse()
        flap.push(...row)
        tag++
    }

    return flap
};
```

解析：

先遍历一次二维数组，将它改变为数组对象，带有值、行标、列标

再次进行遍历，使用规律

第一行第一列的元素 行列标之和为 0

第一行第二列的元素 行列标之和为 1

第二行第一列的元素 行列标之和为 1

以此规律，设置一个标志将对应位置的值不断插入数组中，

需要注意 行列相加为偶数的值，需要翻转获取

最后以模板字符串的形式添加进结果数组中
